<!DOCTYPE HTML>
<html lang="en">
<head>
	<title>Rust</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=792, user-scalable=no">
	<meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="stylesheet" href="shower/themes/bright/styles/screen.css">
    <link rel="stylesheet" href="assets/highlight/styles/xcode.css">
    <link rel="stylesheet" href="assets/main.css">

	<script src="shower/shower.min.js"></script>
    <script src="assets/highlight/highlight.pack.js"></script>
    <script src="assets/main.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-57876722-1', 'auto');
      ga('send', 'pageview');

    </script>
</head>
<body class="list">
    
    
    
    <section class="slide cover" id="Cover"><div>
		<h2>Rust</h2>
		<img src="pictures/rust-logo.svg">

		<style>
            #Cover {
                background: #fff;
            }
            #Cover img {
                height: 400px;
                left: 50%;
                position: absolute;
                top: 50%;
                transform: translateY(-60%) translateX(-50%);
                width: 400;
            }
            #Cover h2 {
                bottom: 60px;
                font-size:90px;
                left: 0;
                position: absolute;
                right: 0;
                text-align:center;
            }
		</style>
	</div></section>



	<section class="slide shout"><div>
		<h2>Ещё один язык?!</h2>
	</div></section>



    <section class="slide cover" id="Languages"><div>
        <img src="pictures/languages.png">
        <style>
            #Languages {
                background: #fff;
            }

            #Languages img {
                left: 20px;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 984px;
            }
        </style>
	</div></section>



    <section class="slide" id="History"><div>
		<h2>Немного истории:</h2>
		<ul>
            <li class="next"><span>2006</span>Грэйдон Хоар начинает работу над языком</li>
			<li class="next"><span>2009</span>К разработке подключается Mozilla</li>
            <li class="next"><span>2010</span>Компилятор переписывают с OCaml на Rust</li>
            <li class="next"><span>2011</span>Rust компилирует сам себя</li>
            <li class="next"><span>2012</span>Первый публичный релиз Rust 0.1</li>
            <li class="next"><span>2013</span>Samsung присоединяется к разработке Servo</li>
            <li class="next"><span>2014</span>Разработка Cargo и <a href="http://crates.io">crates.io</a></li>
            <li class="next"><span>2015</span>Rust 1.0</li>
        </ul>

        <style>
            #History ul > li:before {
                display: none;
            }
            #History ul > li {
                text-indent: 0;
            }
            #History ul > li > span {
                color: #AAA;
                display: inline-block;
                margin-left: -100px;
                padding-right: 10px;
                text-align: right;
                width: 90px;
            }
        </style>
    </div></section>



	<section class="slide"><div>
		<figure>
			<blockquote>
                <p>Rust — это системный язык программирования, который работает невероятно быстро, предотвращает почти все падения и недопускает гонки данных.</p>
                <p>
                    <span class="next">бесплатные абстракции;</span>
                    <span class="next">move-семантика;</span>
                    <span class="next">гарантированная безопастность памяти;</span>
                    <span class="next">многопоточность без гонок данных;</span>
                    <span class="next">дженерики основанные на трейтах;</span>
                    <span class="next">сопоставление с образцом;</span>
                    <span class="next">вывод типов;</span>
                    <span class="next">минимальный рантайм;</span>
                    <span class="next">эфективные С биндинги.</span>
                </p>
			</blockquote>
			<figcaption class="next">www.rust-lang.org</figcaption>
		</figure>
	</div></section>



    <section class="slide"><div>
        <img src="pictures/im-not-ok.png" class="place">
    </div></section>



	<section class="slide"><div>
        <h2>Hello world</h2>
        <pre><code data-language="rust">
            fn main() {
                println!("Hello world");
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Простые типы</h2>
        <ol>
            <li>числа с фиксированным размером:<br>
                <b>i8</b>, ..., <b>i64</b>, <b>u8</b>, ..., <b>u68</b>, <b>f32</b>, <b>f64</b>
            </li>
            <li class="next">с платформозависимым размером: <b>int</b>, <b>uint</b></li>
            <li class="next">массивы: <b>[int, ..2]</b></li>
            <li class="next">строки: <b>str</b></li>
        </ol>
    </div></section>



	<section class="slide"><div>
        <h2>«Переменные»</h2>
        <pre><code data-language="rust">
            fn main() {
                let x = 1i;

                let mut y: int = 2;
                y += 1;
                
                let z: uint;
                z = 4
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Функции</h2>
        <pre><code data-language="rust">
            fn print_number(x: int) {
                println!("x is: {}", x);
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn sum(x: int, y: int) -> int {
                x + y
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                print_number(sum(1, 2));
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Кортежи</h2>
        <pre><code data-language="rust">
            fn main() {
                let x: (int, &str) = (1, "hello");
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn next_two(x: int) -> (int, int) {
                (x + 1i, x + 2i)
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let (x, y) = next_two(5i);
                println!("x, y = {}, {}", x, y);
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Структуры</h2>
        
        <pre><code data-language="rust">
            struct Point {
                x: int,
                y: int,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn print_point(point: Point) {
                println!("The point is at ({}, {})", point.x, point.y);
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let origin = Point { x: 0, y: 0 };
                print_point(origin);

                let mut point = Point { x: 0, y: 0 };
                point.x = 5;
                print_point(point);
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>«Кортежные» структуры и <br>новые типы</h2>
        <pre><code data-language="rust">
            struct Color(int, int, int);

            struct Inches(int); 
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let black  = Color(0, 0, 0);
                let length = Inches(10);
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Перечисления</h2>

        <pre><code data-language="rust">
            enum Ordering {
                Less,
                Equal,
                Greater,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn cmp(a: int, b: int) -> Ordering {
                Ordering::Equal // :)
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let result = cmp(1, 2);
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Перечисления</h2>

        <pre><code data-language="rust">
            enum OptionalInt {
                Value(int),
                Missing,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            enum Direction {
                North = 1,
                West = 2,
                South = 3,
                East = 4
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let x = OptionalInt::Value(1);
                let direction = Direction::North;
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Циклы</h2>
        <pre><code data-language="rust">
            fn main() {
                for x in range(0i, 10) {
                    println!("{}", x);
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let mut i = 0i;
                while i < 10 {
                    i += 1;
                }
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Условия</h2>
        <pre><code data-language="rust">
            fn main() {
                let x = 5i;
                if x == 5i {
                    println!("x is five!");
                } else {
                    println!("x is not five :(");
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let x = 5i;
                let y = if x == 5i { true } else { false };
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Сопоставление с образцом</h2>

        <pre><code data-language="rust">
            fn main() {
                let x: uint = 10;
                let name = match x {
                    1 => "one",
                    2 => "two",
                    _ => "many"
                }; 
                println!("{}", name);
            }
        </code></pre>
    </div></section>



	<section class="slide hide-slide-number"><div>
        <h2>Сопоставление с образцом</h2>

        <pre><code data-language="rust">
            use OptionalInt::{Value, Missing};
            enum OptionalInt {
                Value(int),
                Missing,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn print_optional_int(x: OptionalInt) {
                match x {
                    Value(x) => println!("x is {}", x),
                    Missing  => println!("x is missing")
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                print_optional_int(Value(1));
                print_optional_int(Missing);
            }
        </code></pre>
    </div></section>



	<section class="slide hide-slide-number"><div>
        <h2>Сопоставление с образцом</h2>

        <pre><code data-language="rust">
            fn main() {
                let list = [1i, 2, 3, 4];
                match list {
                    [1, x, rest..] => {
                        println!("2nd: {}, all others: {}", x, rest);
                    }
                    _ => println!("Something else")
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn move((x, y): (int, int), shift: int) -> (int, int) { 
                (x + shift, y + shift)
            }

            fn main() {
                let (x, y) = sum((1, 2), 10);
            } 
        </code></pre>
    </div></section>



	<section class="slide hide-slide-number"><div>
        <h2>Сопоставление с образцом</h2>

        <pre><code data-language="rust">
            fn main() {
                if let Some(x) = from_str::&lt;int&gt;("12345") {
                    println!("number {}", x);
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn next_int() -> Result&lt;int, int&gt; { ... }

            fn main() {
                while let Ok(token) = next_int() {
                    println!("Next token: {}", token);
                }
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Замыкания</h2>

        <pre><code data-language="rust">
            fn main() {
                let x = 5i;
                let add = |number: int| { number + x };
                println!("{}", add(10i))
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn twice(x: int, f: |int| -> int) -> int {
                f(x) + f(x)
            }

            fn main() {
                twice(5i, |x: int| { x * x });
            }
        </code></pre>
    </div></section>



	<section class="slide hide-slide-number"><div>
        <h2>Методы</h2>

        <pre><code data-language="rust">
            struct Circle {
                x: f64,
                y: f64,
                radius: f64,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            impl Circle {
                fn area(&self) -> f64 {
                    std::f64::consts::PI * (self.radius * self.radius)
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
                println!("{}", c.area());
            }
        </code></pre>
    </div></section>



	<section class="slide hide-slide-number"><div>
        <h2>Дженерики</h2>

        <pre><code data-language="rust">
            enum OptionalInt {
                Value(int),
                Missing,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            enum OptionalFloat64 {
                Value(f64),
                Missing,
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            enum Optional&lt;T&gt; {
                Value(T),
                Missing,
            }

            fn main() { let (x, y) = (Value(3i), Value("foobar")); }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Трейты</h2>

        <pre><code data-language="rust">
            trait HasArea {
                fn area(&self) -> f64;
            } 
        </code></pre>

        <pre class="next"><code data-language="rust">
            struct Circle { x: f64, y: f64, radius: f64 }

            impl HasArea for Circle {
                fn area(&self) -> f64 {
                    std::f64::consts::PI * (self.radius * self.radius)
                }
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Трейты</h2>

        <pre><code data-language="rust">
            struct Square { x: f64, y: f64, side: f64 } 

            impl HasArea for Square {
                fn area(&self) -> f64 {
                    self.side * self.side
                }
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn print_area&lt;T: HasArea&gt;shape: T) {
                println!("This shape has an area of {}", shape.area());
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                print_area(Circle { x: 0.0, y: 0.0, radius: 1.0 });
                print_area(Square { x: 0.0, y: 0.0, side: 1.0 });
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Итераторы</h2>

        <pre><code data-language="rust">
            trait Iterator&lt;A&gt; {
                fn next(&mut self) -> Option<A>;
                fn size_hint(&self) -> (uint, Option<uint>) { ... }
            } 
        </code></pre>

        <pre class="next"><code data-language="rust">
            pub trait IteratorExt&lt;A&gt;: Iterator&lt;A&gt; {
                fn chain&lt;U: Iterator&lt;A&gt;&gt;(self, other: U)
                fn zip&lt;B, U: Iterator&lt;B&gt;&gt;(self, other: U)
                fn map&lt;'r, B&gt;(self, f: |A| -&gt; B)
                fn filter&lt;'r&gt;(self, predicate: |&A| -&gt; bool)
                // ...
                // 23
                // ...
            }
        </code></pre>
    </div></section>



	<section class="slide"><div>
        <h2>Итераторы</h2>

        <pre><code data-language="rust">
            fn main() {
                range(1u, 1000)
                    .filter(|&x| x % 2 == 0)
                    .filter(|&x| x % 3 == 0)
                    .map(|&x| x * x)
                    .zip(count(0u, 1u))
                    .take(5)
                    .inspect(|&x| println!("{}", x));
            }
        </code></pre>
    </div></section>



	<section class="slide shout"><div>
		<h2>Failure Driven Development</h2>
	</div></section>



    <section class="slide" id="FDD"><div>
        <h2>Failure Driven Development</h2>
        <dl>
            <div class="next">
                <dt>Java / C# / C++ / etc</dt>
                <dd class="next">
                    write → compile → <mark class="bad">run → fail</mark> → …
                </dd>
            </div>
            <div class="next">
                <dt>Python / Ruby / JS / etc</dt>
                <dd class="next">
                    write → <mark class="bad">run → fail</mark> → …
                </dd>
            </div>
            <div class="next">
                <dt>Haskell / Rust / ???</dt>
                <dd class="next">
                    write → <mark class="good">compile → fail</mark> → … → run
                </dd>
            </div>
        </dl>

        <style>
            #FDD dt, #FDD dd {
                display: inline-block;
                float: left;
            }
            #FDD dt {
                clear: left;
                width: 300px;
            }
            #FDD .bad {
                background: #B00;
                color: #FFF;
            }
            #FDD .good {
                background: #0B0;
                color: #FFF;
            }
        </style>
    </div></section>



	<section class="slide shout"><div>
		<h2>Владение данными</h2>
	</div></section>



	<section class="slide"><div>
		<h2>Ownership and borrowing</h2>
		<p>С помощью статических проверок на их основе компилятор способен предотвратить огромное число ошибок управления ресурсами: use-after-free, double-free, iterator invalidation, data races</p>
		<p>Владение данными основывается на теории <i>линейных типов</i> (linear types). Авторы Rust вдохновлялись языками Clean и Cyclone; см. также unique_ptr в C++</p>
	</div></section>



	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="cpp">
{
	int *x = malloc(sizeof(int));
	
	// do stuff
	*x = 5;
	
	free(x);
}
        </code></pre>
        <pre class="next"><code data-language="rust">
{
	let x = box 5;
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="rust">
fn add_one(mut num: Box&lt;int&gt;) {
    *num += 1;
}
	
let x = box 5i;
	
add_one(x);
	
println!("{}", x);  // ! error: use of moved value: x
        </code></pre>
        <p>Move-семантика в действии!</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="rust">
fn add_one(mut num: Box&lt;int&gt;) -> Box&lt;int&gt; {
    *num += 1;
    num
}
	
let x = box 5i;
	
let y = add_one(x);
	
println!("{}", y);  // 6
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Copy</h2>
		<p>Некоторые типы реализуют трейт <b>Copy</b>; они автоматически копируются вместо перемещения:</p>
		<pre><code data-language="rust">
let x: int = 10;
let y = x;
println!("{}", x);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>RAII</h2>
		<pre><code data-language="rust">
{
    let mut f = File::open(&Path::new("/path")).unwrap();
    // work with file ...
}   // f's destructor is called here
    // (unless it is moved somewhere else)
        </code></pre>
        <p>Ownership + move semantics + деструкторы = безопасный RAII. <br> Но move semantics подразумевает передачу права владения, что возможно далеко не всегда:</p>
		<pre><code data-language="rust">
let mut f = File::open(&Path::new("/path")).unwrap();
let buf = [0u8, ..128];
f.read(buf).unwrap();
println!("{}", buf);  // ! use of moved value: buf
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing</h2>
		<p>Владелец данных может предоставить к ним доступ с помощью <i>ссылок</i>:</p>
		<pre><code data-language="rust">
fn with_one(num: &int) -> int {
    *num + 1
}
	
let x = box 5i;
	
println!("{}", with_one(&*x));  // 6
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Borrowing</h2>
		<ol>
			<ul>
				<li><b>&T</b> — разделяемые/иммутабельные (shared/immutable)</li>
				<li><b>&mut T</b> — неразделяемые/мутабельные (exclusive/mutable)</li>
			</ul>
		</ol>
		<pre><code data-language="rust">
let x = 10i;
let p1 = &x;
let p2 = &x;  // ok
        </code></pre>
        <pre><code data-language="rust">
let mut x = 10i;
let p1 = &mut x;
let p2 = &x;  // ! cannot borrow x as immutable because 
              // ! it is also borrowed as mutable
        </code></pre>
        <pre><code data-language="rust">
let mut x = 10i;
let p1 = &mut x;
let p2 = &mut x;  // ! cannot borrow x as mutable 
                  // ! more than once at a time
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing and mutability</h2>
		<p>«Эксклюзивность» мутабельных ссылок исключает очень большой класс ошибок вида use-after-free (и не только):</p>
		<pre><code data-language="rust">
let mut v: Vec&lt;int&gt; = vec![1, 2];
let e = &v[0];
v.push(3);  // reallocates the vector, moving its contents
            // ! cannot borrow v as mutable because 
            // ! it is also borrowed as immutable
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing and mutability</h2>
        <pre><code data-language="rust">
let mut num = box 5i;
let e = &*num;
num = box 6i; //! can't assign to num because it's borrowed
        </code></pre>
        <pre><code data-language="rust">
let mut v = vec![1i, 2, 3];
for &e in v.iter() {
    println!("{}", e);
    if e == 2 { v.push(-42); } //! can't borrow v as mutable
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>«Наивное» заимствование может вызвать проблемы:</p>
		<ol>
			<li>создаётся ресурс X;</li>
			<li>на ресурс X берётся ссылка a;</li>
			<li>ресурс X уничтожается;</li>
			<li>к [уничтоженному] ресурсу X осуществляется доступ через ссылку a.</li>
		</ol>
		<p>Use after free, доступ к закрытому файлу, etc.<br>Решение — <b>статически</b> обеспечить невозможность 4 перед 3.</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>С каждой ссылкой ассоциирован параметр — время жизни того объекта, на который она указывает. Компилятор статически проверяет, что каждая ссылка всегда «живёт» меньше, чем исходный объект:</p>
		<pre><code data-language="rust">
fn make_ref<'a>() -> &'a int {
    let x = 10i;
    &x  // ! x does not live long enough
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
        <pre><code data-language="rust">
fn first_and_last<'a>(slice: &'a [T]) -> (&'a T, &'a T) {
    (&slice[0], &slice[slice.len()-1])
}
        </code></pre>
        <pre><code data-language="rust">
fn first_and_last(slice: &[T]) -> (&T, &T) {  // identical
    (&slice[0], &slice[slice.len()-1])
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>Lifetime-параметры можно ассоциировать с областями видимости:</p>
		<pre><code data-language="rust">
let x;
{
    let n = 5i;
    x = &n;  // ! n does not live long enough
}
println!("{}", *x);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>Lifetime-параметры «заражают» типы:</p>
		<pre><code data-language="rust">
struct AnIntReference<'a> {
    r: &'a int
}
enum MaybeOwned<'a> {
    Owned(String),
    Slice(&'a str)
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Lifetimes</h2>
		<p>Идентификатор 'static обозначает время жизни всей программы:</p>
		<pre><code data-language="rust">
static ANSWER: int = 42;
fn print_static_int_only(r: &'static int) {  // '
    println!("{}", *r);
}
fn main() {
    print_static_int_only(&ANSWER);  // ok
    let r = 21;
    print_static_int_only(&r);  // ! r does not
								// live long enough
}
        </code></pre>
        <pre><code data-language="rust">
const MESSAGE: &'static str = "Hello world!";
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Shared ownership</h2>
		<p>В рамках одного потока — подсчёт ссылок:</p>
		<pre><code data-language="rust">
use std::rc::Rc;
{
    let r = Rc::new(vec![1, 2, 3]);
    let r2 = r.clone();
    println!("{}", *r);
    println!("{}", *r2);
}  // both references go out of scope, Vec is destroyed
        </code></pre>
	</div></section>
	
	
	
	<section class="slide shout"><div>
		<h2>Многопоточность</h2>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Потоки</h2>
		<p>Создаются функцией spawn():</p>
		<pre><code data-language="rust">
spawn(proc() {  // unboxed closure
    println!("Hello from other thread!");
});
        </code></pre>
        <p>Потоки — это потоки ОС.<br>Система типов гарантирует, что замыкание не захватит «опасные» переменные.</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Каналы</h2>
		<p>Общение между потоками происходит через каналы:</p>
		<pre><code data-language="rust">
let (tx, rx) = channel();
spawn(proc() {
    tx.send(4u + 6);
    tx.send(5u + 7);
});
println!("{}, {}", rx.recv(), rx.recv());
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Shared state</h2>
		<p>Данные «без ссылок внутри» разделяемые с помощью Arc:</p>
		<pre><code data-language="rust">
use std::sync::Arc;
	
let data = Arc::new(vec![1u, 2, 3]);
	
let for_thread = data.clone();
spawn(proc() {
    println!("From spawned thread: {}", *for_thread);
});
	
println!("From main thread: {}", *data);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Mutable shared state</h2>
		<p>За счёт системы типов использование синхронизации <i>обязательно</i>. Таким образом, исключаются гонки данных
(data races):</p>
		<pre><code data-language="rust">
use std::sync::{Arc, Mutex};
let data = Arc::new(Mutex::new(vec![1u, 2, 3]));
let for_thread = data.clone();
	
spawn(proc() {
    let mut guard = for_thread.lock();
    guard.push(4);
    println!("{}", *guard);
});
let mut guard = data.lock();
guard.push(5);
println!("{}", *guard);
        </code></pre>
	</div></section>
	
	
	
    <section class="slide shout"><div>
		<h2>Unsafe</h2>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Что это такое</h2>
		<p>unsafe-блоки и unsafe-функции:</p>
		<pre><code data-language="rust">
unsafe fn from_raw_buf<'a, T>(p: &'a *const T, 
                              n: uint) -> &'a [u8] {
    std::mem::transmute(std::raw::Slice {
        data: *p,
        len: n
    })
}
        </code></pre>
        <pre><code data-language="rust">
fn fill_buffer<R: Reader>(r: R, size: uint) -> Vec<u8> {
    let v = Vec::with_capacity(size);
    unsafe { v.set_len(size) };
    r.read(v.as_mut_slice()).unwrap();
    v
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Unsafe-операции</h2>
		<ol>
			<ul>
				<li>разыменование «сырого» указателя:</li>
					<pre><code data-language="rust">
let n = 10i;
let p = &n as *const int;
println!("{}", unsafe { *p });
					</code></pre>
				<li>чтение/запись статической мутабельной переменной:</li>
					<pre><code data-language="rust">
static mut COUNTER: u32 = 10;
unsafe { COUNTER += 32 };
println!("{}", unsafe { COUNTER });
					</code></pre>
				<li>вызов unsafe-функции:</li>
					<pre><code data-language="rust">
extern { fn perror(); }
unsafe { perror(); }
					</code></pre>
			</ul>
		</ol>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Использование С-library из Rust</h2>
		<p>Импорт функции</p>
		<pre><code data-language="rust">
extern crate libc;
use libc::size_t;
	
#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length
		(source_length: size_t) -> size_t;
}
	
fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max length of a 100 byte buffer: {}", x);
}
		</code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Использование С-library из Rust</h2>
		<p>Для заголовочного файла С</p>
		<pre><code data-language="с">
#ifndef UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_
#define UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_
#include &lt;stddef.h&gt;

...
	
// Returns the maximal size of the compressed 
// representation of input data that
// has length of source bytes

size_t snappy_max_compressed_length(size_t source_length);

#endif /* UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_ */
		</code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Callbacks from C to Rust</h2>
		<pre><code data-language="rust">
extern fn callback(a: i32) {
    println!("I'm called from C with value {0}", a);
}
	
#[link(name = "extlib")]
extern {
   fn register_callback(cb: extern fn(i32)) -> i32;
   fn trigger_callback();
}
	
fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Triggers the callback
    }
}
		</code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Callbacks from C to Rust</h2>
		<pre><code data-language="c">
typedef void (*rust_callback)(int32_t);
rust_callback cb;
	
int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}
	
void trigger_callback() {
  cb(7); // Will call callback(7) in Rust
}
		</code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Rust и Assembler</h2>
		<pre><code data-language="rust">
#![feature(asm)]
	
#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
fn foo() {
    unsafe {
        asm!("NOP");
    }
}
// other platforms
#[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
fn foo() { /* ... */ }
	
fn main() {
    foo();
    // ...
}
		</code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Rust и Assembler</h2>
		<pre><code data-language="rust">
fn add(a: int, b: int) -> int {
    let mut c = 0;
    unsafe {
        asm!("add $2, $0"
             : "=r"(c)
             : "0"(a), "r"(b)
             );
    }
    c
}
	
fn main() {
    assert_eq!(add(3, 14159), 14162)
}
		</code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Когда это нужно</h2>
		<ol>
			<ul>
				<li>ещё больше производительности</li>
				<li>взаимодействие с внешними библиотеками</li>
			</ul>
		</ol>
		<p>Другими словами — для системного программирования!</p>
	</div></section>



    <section class="slide shout"><div>
        <h2>Инфраструктура</h2>
    </div></section>



    <section class="slide"><div>
        <h2>Crate</h2>

		<pre><code data-language="rust">
            extern crate foo;

            use foo::{bar, baz};

            pub mod a {
                mod b {
                    // ...
                }
                pub mod c {
                    // ...
                }
            }
            mod d {
                // ...
            }
		</code></pre>
    </div></section>



    <section class="slide"><div>
        <h2>Тесты</h2>

		<pre><code data-language="rust">
            #[test]
            fn test_something() {
                assert_eq!(true, true);
            }

            #[bench]
            fn test_perf(b: &mut Bencher) {
                b.iter(|| {
                    do_something();
                });
            }
		</code></pre>
    </div></section>



    <section class="slide"><div>
        <h2>Cargo</h2>

        <ul>
            <li>отслеживание зависимостей</li>
            <li>компиляция зависимостей</li>
            <li>компиляция проекта</li>
            <li>запуск тестов/бенчмарков</li>
            <li>деплой пакетов в репозиторий</li>
        </ul>

        <h2>crates.io</h2>

        <ul><li>400 пакетов за полторы недели</li></ul>

    </div></section>
    


    <section class="slide shout"><div>
        <h2>Что посмотреть?</h2>
    </div></section>



    <section class="slide hide-slide-number"><div>
        <h2>Servo</h2>
        <ul>
            <li>исследовательский браузерный движок</li>
            <li>активно развивается, уже проходит какие-то тесты</li>
            <li>~100000 строк</li>
            <li>https://github.com/servo/</li>
        </ul>
            
        <h2>Cargo</h2>
        <ul>
            <li>менеджер сборки</li>
            <li>новый проект, idiomatic style</li>
            <li>~30000 строк</li>
            <li>https://github.com/rust-lang/cargo</li>
        </ul>
    </div></section>



    <section class="slide hide-slide-number"><div>
        <ul>
            <li>www.rust-lang.org</li>
            <li>play.rust-lang.org</li>
            <li>crates.io</li>
            <li>doc.rust-lang.org/guide.html</li>
            <li>doc.rust-lang.org</li>
            <li>github.com/rust-lang</li>
        </ul>
    </div></section>



    <section class="slide"><div>
        <img src="pictures/im-ok.png" class="place">
    </div></section>
    


	<section class="slide shout"><div>
		<h2>Вопросы?</h2>
	</div></section>



	<div class="progress"><div></div></div>
</body>
</html>
