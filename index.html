<!DOCTYPE HTML>
<html lang="en">
<head>
	<title>Rust</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=792, user-scalable=no">
	<meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="stylesheet" href="shower/themes/bright/styles/screen.css">
    <link rel="stylesheet" href="assets/highlight/styles/xcode.css">
    <link rel="stylesheet" href="assets/main.css">

	<script src="shower/shower.min.js"></script>
    <script src="assets/highlight/highlight.pack.js"></script>
    <script src="assets/main.js"></script>
</head>
<body class="list">
    
    
    
    <section class="slide cover" id="Cover"><div>
		<h2>Rust</h2>
		<img src="pictures/rust-logo.svg">

		<style>
            #Cover {
                background: #fff;
            }
            #Cover img {
                height: 400px;
                left: 50%;
                position: absolute;
                top: 50%;
                transform: translateY(-60%) translateX(-50%);
                width: 400;
            }
            #Cover h2 {
                bottom: 60px;
                font-size:90px;
                left: 0;
                position: absolute;
                right: 0;
                text-align:center;
            }
		</style>
	</div></section>



	<section class="slide shout"><div>
		<h2>Ещё один язык?!</h2>
	</div></section>



    <section class="slide cover" id="Languages"><div>
        <img src="pictures/languages.png">
        <style>
            #Languages {
                background: #fff;
            }

            #Languages img {
                left: 20px;
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                width: 984px;
            }
        </style>
	</div></section>



    <section class="slide" id="History"><div>
		<h2>Немного истории:</h2>
		<ul>
            <li class="next"><span>2006</span>Грэйдон Хоар начинает работу над языком</li>
			<li class="next"><span>2009</span>К разработке подключается Mozilla</li>
            <li class="next"><span>2010</span>Компилятор переписывают с OCaml на Rust</li>
            <li class="next"><span>2011</span>Rust компилирует сам себя</li>
            <li class="next"><span>2012</span>Первый публичный релиз Rust 0.1</li>
            <li class="next"><span>2013</span>Samsung присоединяется к разработке Servo</li>
            <li class="next"><span>2014</span>Разработка Cargo и <a href="http://crates.io">crates.io</a></li>
            <li class="next"><span>2015</span>Rust 1.0</li>
        </ul>

        <style>
            #History ul > li:before {
                display: none;
            }
            #History ul > li {
                text-indent: 0;
            }
            #History ul > li > span {
                color: #AAA;
                display: inline-block;
                margin-left: -100px;
                padding-right: 10px;
                text-align: right;
                width: 90px;
            }
        </style>
    </div></section>



	<section class="slide"><div>
		<figure>
			<blockquote>
                <p>Rust — это системный язык программирования, который работает невероятно быстро, предотвращает почти все падения и недопускает гонки данных.</p>
                <p>
                    <span class="next">бесплатные абстракции;</span>
                    <span class="next">move-семантика;</span>
                    <span class="next">гарантированная безопастность памяти;</span>
                    <span class="next">многопоточность без гонок данных;</span>
                    <span class="next">дженерики основанные на трейтах;</span>
                    <span class="next">сопоставление с образцом;</span>
                    <span class="next">вывод типов;</span>
                    <span class="next">минимальный рантайм;</span>
                    <span class="next">эфективные С биндинги.</span>
                </p>
			</blockquote>
			<figcaption class="next">www.rust-lang.org</figcaption>
		</figure>
	</div></section>



    <section class="slide"><div>
        <img src="pictures/im-not-ok.png" class="place">
    </div></section>



	<section class="slide"><div>
		<h2>Hello world</h2>
        <pre class="next"><code data-language="rust">
            fn main() {
                println!("Hello world");
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                let name = "world";
                println!("Hello {}", name);
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn hello(name: &str) {
                println!("Hello {}", name);
            }

            fn main() {
                hello("world");
            }
        </code></pre>

    </div></section>



	<section class="slide"><div>
		<h2>Hello world</h2>
        <pre><code data-language="rust">
            fn hello(name: &str) -> String {
                format!("Hello {}", name)
            }

            fn main() {
                println!("{}", hello("world"));
            }
        </code></pre>

        <pre class="next"><code data-language="rust">
            fn main() {
                for number in range(1u, 100) {
                    if number % 2 == 0 {
                        println!("{}", number);
                    }
                }
            }
        </code></pre>
    </div></section>



	<section class="slide shout"><div>
		<h2>Failure Driven Development</h2>
	</div></section>



    <section class="slide" id="FDD"><div>
        <h2>Failure Driven Development</h2>
        <dl>
            <div class="next">
                <dt>Java / C# / C++ / etc</dt>
                <dd class="next">
                    compile → <mark class="bad">run → fail</mark> → …
                </dd>
            </div>
            <div class="next">
                <dt>Python / Ruby / JS / etc</dt>
                <dd class="next">
                    <mark class="bad">run → fail</mark> → …
                </dd>
            </div>
            <div class="next">
                <dt>Haskell / Rust / ???</dt>
                <dd class="next">
                    <mark class="good">compile → fail</mark> → … → run
                </dd>
            </div>
        </dl>

        <style>

            #FDD dt, #FDD dd {
                display: inline-block;
                float: left;
            }
            #FDD dt {
                clear: left;
                width: 300px;
            }
            #FDD .bad {
                background: #B00;
                color: #FFF;
            }
            #FDD .good {
                background: #0B0;
                color: #FFF;
            }
        </style>
    </div></section>



	<section class="slide shout"><div>
		<h2>Владение данными</h2>
	</div></section>



	<section class="slide"><div>
		<h2>Ownership and borrowing</h2>
		<p>С помощью статических проверок на их основе компилятор способен предотвратить огромное число ошибок управления ресурсами: use-after-free, double-free, iterator invalidation, data races</p>
		<p>Владение данными основывается на теории <i>линейных типов</i> (linear types). Авторы Rust вдохновлялись языками Clean и Cyclone; см. также unique_ptr в C++</p>
	</div></section>



	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="cpp">
{
	int *x = malloc(sizeof(int));
	
	// do stuff
	*x = 5;
	
	free(x);
}
        </code></pre>
        <pre><code data-language="rust">
{
	let x = box 5;
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="rust">
fn add_one(mut num: Box<int>) {
    *num += 1;
}
	
let x = box 5i;
	
add_one(x);
	
println!("{}", x);  // ! error: use of moved value: x
        </code></pre>
        <p>Move-семантика в действии!</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Ownership</h2>
		<pre><code data-language="rust">
fn add_one(mut num: Box<int>) -> Box<int> {
    *num += 1;
    num
}
	
let x = box 5i;
	
let y = add_one(x);
	
println!("{}", y);  // 6
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Copy</h2>
		<p>Некоторые типы реализуют трейт <b>Copy</b>; они автоматически копируются вместо перемещения:</p>
		<pre><code data-language="rust">
let x: int = 10;
let y = x;
println!("{}", x);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>RAII</h2>
		<pre><code data-language="rust">
{
    let mut f = File::open(&Path::new("/path")).unwrap();
    // work with file ...
}   // f's destructor is called here
    // (unless it is moved somewhere else)
        </code></pre>
        <p>Ownership + move semantics + деструкторы = безопасный RAII. <br> Но move semantics подразумевает передачу права владения, что возможно далеко не всегда:</p>
		<pre><code data-language="rust">
let mut f = File::open(&Path::new("/path")).unwrap();
let buf = [0u8, ..128];
f.read(buf).unwrap();
println!("{}", buf);  // ! use of moved value: buf
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing</h2>
		<p>Владелец данных может предоставить к ним доступ с помощью <i>ссылок</i>:</p>
		<pre><code data-language="rust">
fn with_one(num: &int) -> int {
    *num + 1
}
	
let x = box 5i;
	
println!("{}", with_one(&*x));  // 6
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Borrowing</h2>
		<ol>
			<ul>
				<li><b>&T</b> — разделяемые/иммутабельные (shared/immutable)</li>
				<li><b>&mut T</b> — неразделяемые/мутабельные (exclusive/mutable)</li>
			</ul>
		</ol>
		<pre><code data-language="rust">
let x = 10i;
let p1 = &x;
let p2 = &x;  // ok
        </code></pre>
        <pre><code data-language="rust">
let mut x = 10i;
let p1 = &mut x;
let p2 = &x;  // ! cannot borrow x as immutable because 
              // ! it is also borrowed as mutable
        </code></pre>
        <pre><code data-language="rust">
let mut x = 10i;
let p1 = &mut x;
let p2 = &mut x;  // ! cannot borrow x as mutable 
                  // ! more than once at a time
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing and mutability</h2>
		<p>«Эксклюзивность» мутабельных ссылок исключает очень большой класс ошибок вида use-after-free (и не только):</p>
		<pre><code data-language="rust">
let mut v: Vec<int> = vec![1, 2];
let e = &v[0];
v.push(3);  // reallocates the vector, moving its contents
            // ! cannot borrow v as mutable because 
            // ! it is also borrowed as immutable
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Borrowing and mutability</h2>
        <pre><code data-language="rust">
let mut num = box 5i;
let e = &*num;
num = box 6i; //! can't assign to num because it's borrowed
        </code></pre>
        <pre><code data-language="rust">
let mut v = vec![1i, 2, 3];
for &e in v.iter() {
    println!("{}", e);
    if e == 2 { v.push(-42); } //! can't borrow v as mutable
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>«Наивное» заимствование может вызвать проблемы:</p>
		<ol>
			<li>создаётся ресурс X;</li>
			<li>на ресурс X берётся ссылка a;</li>
			<li>ресурс X уничтожается;</li>
			<li>к [уничтоженному] ресурсу X осуществляется доступ через ссылку a.</li>
		</ol>
		<p>Use after free, доступ к закрытому файлу, etc.<br>Решение — <b>статически</b> обеспечить невозможность 4 перед 3.</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>С каждой ссылкой ассоциирован параметр — время жизни того объекта, на который она указывает. Компилятор статически проверяет, что каждая ссылка всегда «живёт» меньше, чем исходный объект:</p>
		<pre><code data-language="rust">
fn make_ref<'a>() -> &'a int {
    let x = 10i;
    &x  // ! x does not live long enough
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
        <pre><code data-language="rust">
fn first_and_last<'a>(slice: &'a [T]) -> (&'a T, &'a T) {
    (&slice[0], &slice[slice.len()-1])
}
        </code></pre>
        <pre><code data-language="rust">
fn first_and_last(slice: &[T]) -> (&T, &T) {  // identical
    (&slice[0], &slice[slice.len()-1])
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>Lifetime-параметры можно ассоциировать с областями видимости:</p>
		<pre><code data-language="rust">
let x;
{
    let n = 5i;
    x = &n;  // ! n does not live long enough
}
println!("{}", *x);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Lifetimes</h2>
		<p>Lifetime-параметры «заражают» типы:</p>
		<pre><code data-language="rust">
struct AnIntReference<'a> {
    r: &'a int
}
enum MaybeOwned<'a> {
    Owned(String),
    Slice(&'a str)
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Lifetimes</h2>
		<p>Идентификатор 'static обозначает время жизни всей программы:</p>
		<pre><code data-language="rust">
static ANSWER: int = 42;
fn print_static_int_only(r: &'static int) {  // '
    println!("{}", *r);
}
fn main() {
    print_static_int_only(&ANSWER);  // ok
    let r = 21;
    print_static_int_only(&r);  // ! r does not
								// live long enough
}
        </code></pre>
        <pre><code data-language="rust">
const MESSAGE: &'static str = "Hello world!";
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Shared ownership</h2>
		<p>В рамках одного потока — подсчёт ссылок:</p>
		<pre><code data-language="rust">
use std::rc::Rc;
{
    let r = Rc::new(vec![1, 2, 3]);
    let r2 = r.clone();
    println!("{}", *r);
    println!("{}", *r2);
}  // both references go out of scope, Vec is destroyed
        </code></pre>
	</div></section>
	
	
	
	<section class="slide shout"><div>
		<h2>Многопоточность</h2>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Потоки</h2>
		<p>Создаются функцией spawn():</p>
		<pre><code data-language="rust">
spawn(move || {  // unboxed closure
    println!("Hello from other thread!");
});
        </code></pre>
        <p>Потоки — это потоки ОС.<br>Система типов гарантирует, что замыкание не захватит «опасные» переменные.</p>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Каналы</h2>
		<p>Общение между потоками происходит через каналы:</p>
		<pre><code data-language="rust">
let (tx, rx) = channel();
spawn(move || {
    tx.send(4u + 6);
    tx.send(5u + 7);
});
println!("{}, {}", rx.recv(), rx.recv());
        </code></pre>
	</div></section>
	
	
	
	<section class="slide"><div>
		<h2>Shared state</h2>
		<p>Данные «без ссылок внутри» разделяемые с помощью Arc:</p>
		<pre><code data-language="rust">
use std::sync::Arc;
	
let data = Arc::new(vec![1u, 2, 3]);
	
let for_thread = data.clone();
spawn(move || {
    println!("From spawned thread: {}", *for_thread);
});
	
println!("From main thread: {}", *data);
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Mutable shared state</h2>
		<p>За счёт системы типов использование синхронизации <i>обязательно</i>. Таким образом, исключаются гонки данных
(data races):</p>
		<pre><code data-language="rust">
use std::sync::{Arc, Mutex};
let data = Arc::new(Mutex::new(vec![1u, 2, 3]));
let for_thread = data.clone();
	
spawn(move || {
    let mut guard = for_thread.lock();
    guard.push(4);
    println!("{}", *guard);
});
let mut guard = data.lock();
guard.push(5);
println!("{}", *guard);
        </code></pre>
	</div></section>
	
	
	
	<!-- ROMAN SHMATOV SECTION STARTS -->

	<!-- Как это выглядит на высоком уровне? -->
	
	<!-- ROMAN SHMATOV SECTION ENDS -->



    <section class="slide shout"><div>
		<h2>Unsafe</h2>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Что это такое</h2>
		<p>unsafe-блоки и unsafe-функции:</p>
		<pre><code data-language="rust">
unsafe fn from_raw_buf<'a, T>(p: &'a *const T, 
                              n: uint) -> &'a [u8] {
    std::mem::transmute(std::raw::Slice {
        data: *p,
        len: n
    })
}
        </code></pre>
        <pre><code data-language="rust">
fn fill_buffer<R: Reader>(r: R, size: uint) -> Vec<u8> {
    let v = Vec::with_capacity(size);
    unsafe { v.set_len(size) };
    r.read(v.as_mut_slice()).unwrap();
    v
}
        </code></pre>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Unsafe-операции</h2>
		<ol>
			<ul>
				<li>разыменование «сырого» указателя:</li>
					<pre><code data-language="rust">
let n = 10i;
let p = &n as *const int;
println!("{}", unsafe { *p });
					</code></pre>
				<li>чтение/запись статической мутабельной переменной:</li>
					<pre><code data-language="rust">
static mut COUNTER: u32 = 10;
unsafe { COUNTER += 32 };
println!("{}", unsafe { COUNTER });
					</code></pre>
				<li>вызов unsafe-функции:</li>
					<pre><code data-language="rust">
extern { fn perror(); }
unsafe { perror(); }
					</code></pre>
			</ul>
		</ol>
	</div></section>
	
	
	
	<section class="slide hide-slide-number"><div>
		<h2>Когда это нужно</h2>
		<ol>
			<ul>
				<li>ещё больше производительности</li>
				<li>абстракции</li>
				<li>взаимодействие с внешними библиотеками</li>
			</ul>
		</ol>
		<p>Другими словами — очень редко!</p>
	</div></section>
	
	
	<section class="slide hide-slide-number"><div>
        <h2>Single block</h2>
        <pre><code data-language="rust">
            use std::io;
            use std::os;
                
            fn main() {
                let args = os::args();
                if args.len() != 2 {
                    return;
                }
                let word = &args[1];
                let mut reader = io::stdin();
                let mut filtered = reader.lines()
                    .filter_map(|line| line.ok())
                    .filter(|line| line.as_slice().contains(word));
                for line in filtered {
                    print!("{}", line);
                }
            }
        </code></pre>
    </div></section>



	<div class="progress"><div></div></div>
</body>
</html>
